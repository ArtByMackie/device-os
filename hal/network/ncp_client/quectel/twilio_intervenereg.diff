diff --git hal/network/ncp_client/quectel/quectel_ncp_client.cpp hal/network/ncp_client/quectel/quectel_ncp_client.cpp
index 14764062c..cdf8bff94 100644
--- hal/network/ncp_client/quectel/quectel_ncp_client.cpp
+++ hal/network/ncp_client/quectel/quectel_ncp_client.cpp
@@ -129,6 +129,8 @@ const char QUECTEL_DEFAULT_PDP_TYPE[] = "IP";
 
 } // anonymous
 
+bool cell_imsi_check = 0;
+
 QuectelNcpClient::QuectelNcpClient() {
 }
 
@@ -299,9 +301,18 @@ int QuectelNcpClient::initParser(Stream* stream) {
         }
         return SYSTEM_ERROR_NONE;
     }, this));
+    CHECK(parser_.addUrcHandler("+QUSIM: 1", [](AtResponseReader* reader, const char* prefix, void* data) -> int {
+        const auto self = (QuectelNcpClient*)data;
+        char atResponse[64] = {};
+        // Take a copy of AT response for multi-pass scanning
+        CHECK_PARSER_URC(reader->readLine(atResponse, sizeof(atResponse)));
+        cell_imsi_check = 1;
+        return SYSTEM_ERROR_NONE;
+    }, this));
     return SYSTEM_ERROR_NONE;
 }
 
+
 int QuectelNcpClient::on() {
     const NcpClientLock lock(this);
     if (ncpState_ == NcpState::DISABLED) {
@@ -937,7 +948,7 @@ int QuectelNcpClient::changeBaudRate(unsigned int baud) {
     return serial_->setBaudRate(baud);
 }
 
-int QuectelNcpClient::initReady(ModemState state) {
+int QuectelNcpClient::initReady(ModemState state) { // to difference btw cold n warm boot / cops / checkruntimestate
     // Set modem full functionality
     int r = CHECK_PARSER(parser_.execCommand("AT+CFUN=1,0"));
     CHECK_TRUE(r == AtResponse::OK, SYSTEM_ERROR_UNKNOWN);
@@ -1519,12 +1530,20 @@ int QuectelNcpClient::interveneRegistration() {
                 CHECK_PARSER_OK(parser_.execCommand(QUECTEL_CFUN_TIMEOUT, "AT+CFUN=1"));
             }
         }
+        if(eps_.duration() >= timeout /* && twilio sim */) {
+            CHECK_PARSER_OK(parser_.execCommand(QUECTEL_CFUN_TIMEOUT, "AT+CFUN=4"));
+            CHECK_PARSER_OK(parser_.execCommand(QUECTEL_CFUN_TIMEOUT, "AT+CFUN=1"));
+        }
     }
     return 0;
 }
 
 int QuectelNcpClient::processEventsImpl() {
     CHECK_TRUE(ncpState_ == NcpState::ON, SYSTEM_ERROR_INVALID_STATE);
+    if (cell_imsi_check) {
+        cell_imsi_check = 0;
+        CHECK_PARSER(parser_.execCommand("AT+CIMI"));
+    }
     parser_.processUrc(); // Ignore errors
     checkRegistrationState();
     interveneRegistration();
